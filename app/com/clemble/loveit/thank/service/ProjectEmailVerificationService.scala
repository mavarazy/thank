package com.clemble.loveit.thank.service

import java.time.LocalDateTime
import java.util.UUID

import com.clemble.loveit.common.error.FieldValidationError
import com.clemble.loveit.common.model._
import com.clemble.loveit.common.service.{EmailService, TokenRepository, URLValidator}
import com.clemble.loveit.thank.model.UserProjects
import com.clemble.loveit.thank.service.repository.EmailProjectOwnershipRepository
import javax.inject.{Inject, Singleton}
import play.api.libs.json.{Json, OFormat}

import scala.concurrent.{ExecutionContext, Future}

case class EmailProjectOwnershipToken(
  user: UserID,
  email: Email,
  token: UUID = UUID.randomUUID(),
  created: LocalDateTime = LocalDateTime.now()
) extends Token

object EmailProjectOwnershipToken {

  implicit val json: OFormat[EmailProjectOwnershipToken] = Json.format[EmailProjectOwnershipToken]

}

@Singleton
case class EmailProjectOwnershipService @Inject()(
  emailService: EmailService,
  urlValidator: URLValidator,
  enrichService: ProjectEnrichService,
  repo: EmailProjectOwnershipRepository,
  tokenRepo: TokenRepository[EmailProjectOwnershipToken]
)(implicit ec: ExecutionContext) extends ProjectOwnershipService {

  def create(user: UserID, email: Email): Future[UserProjects] = {
    for {
      urlOpt <- urlValidator.findAlive(email.toEmailDomain())
      _ = if (urlOpt.isEmpty) throw FieldValidationError("url", "Can't connect")
      baseProject <- enrichService.enrich(user, urlOpt.get)
      emailProject = baseProject.asEmailProject(email)
      usrPrj <- repo.saveEmailProjects(user, Seq(emailProject))
    } yield {
      sendVerification(user, email)
      usrPrj
    }
  }

  def sendVerification(user: UserID, email: Email): Future[EmailProjectOwnershipToken] = {
    for {
      token <- tokenRepo.save(EmailProjectOwnershipToken(user, email))
      emailSent <- emailService.sendDomainVerificationEmail(token)
    } yield {
      if (!emailSent) throw new IllegalArgumentException("Failed to send email")
      token
    }
  }

  def verify(user: UserID, token: UUID): Future[UserProjects] = {
    for {
      tokenOpt <- tokenRepo.findAndRemoveByToken(token)
      _ = if (tokenOpt.isEmpty) throw new IllegalArgumentException("Token expired regenerate it")
      token = tokenOpt.get
      _ = if (token.user != user) throw new IllegalArgumentException("Generated by different user")
      usrPrj <- repo.validateEmailProject(token.user, token.email)
    } yield {
      usrPrj
    }
  }

  def delete(user: UserID, email: Email): Future[UserProjects] = {
    for {
      usrPrj <- repo.deleteEmailProject(user, email)
    } yield {
      usrPrj
    }
  }

}